// Made by Pranksterria

/*
  Automatically sets up the backend of the menu bar for you so you can get right into making one with no trouble. Have fun!
*/

#pragma once
#include <Windows.h>
#include <iostream>
#include <functional>
#include <map>

static WNDPROC oldWndProc = NULL;
static std::map<int, std::function<void()>> buttonCallbacks; // gotta be global cuz handler needs it :(

void callbackHandler(int buttonid)
{
	if (buttonCallbacks[buttonid]) {
		buttonCallbacks[buttonid](); // no need to worry about threading here, we already called this func with a new thread
	}
}

LRESULT CALLBACK hookedHandler(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) // cant be a class member
{
	switch (uMsg) {
	case WM_COMMAND: {
		if (HIWORD(wParam) == 0) { // is menu
			std::thread(callbackHandler, LOWORD(wParam)).detach(); // need to multi-thread so I don't hold up messages.
		}
		break;
	}
	}

	if (oldWndProc == NULL) return DefWindowProcA(hwnd, uMsg, wParam, lParam); // better than nothing
	return CallWindowProcA(oldWndProc, hwnd, uMsg, wParam, lParam);
}

class MenuBar
{
private:
	HWND robloxWindow = NULL;
	HMENU menuBar = NULL;
	std::map<int, HMENU> dropdowns;
	int autoID = 10000; // dont make ur IDS around 10k or you'll mess with automatic ID
public:
	MenuBar()
	{
		menuBar = CreateMenu();
		robloxWindow = FindWindowW(NULL, L"Roblox");
		if (menuBar == NULL) std::cout << "Failed to setup menu!\n";
		if (robloxWindow == NULL) std::cout << "Failed to find roblox window!\n";
	}

	void hookMessageHandler()
	{
		oldWndProc = reinterpret_cast<WNDPROC>(SetWindowLongA(robloxWindow, GWL_WNDPROC, reinterpret_cast<LONG>(hookedHandler)));
		if (oldWndProc == NULL) std::cout << "Failed to hook message handler!\n";
	}

	void toggleMenu(bool visible)
	{
		if (visible) {
			SetMenu(robloxWindow, menuBar);
		}
		else {
			SetMenu(robloxWindow, NULL);
		}
	}

	void addButton(const char* name, std::function<void()> f, int dropdownID = 0, int buttonID = 0)
	{
		if (buttonID == 0) {
			buttonID = autoID++;
		}
		buttonCallbacks[buttonID] = f;
		if (dropdownID == 0) {
			AppendMenu(menuBar, MF_ENABLED | MF_STRING, buttonID, name);
			return;
		}
		AppendMenu(dropdowns[dropdownID], MF_ENABLED | MF_STRING, buttonID, name);
	}

	void addText(const char* text, int dropdownID = 0)
	{
		if (dropdownID == 0) {
			AppendMenu(menuBar, MF_DISABLED | MF_STRING, autoID++, text);
			return;
		}
		AppendMenu(dropdowns[dropdownID], MF_DISABLED | MF_STRING, autoID++, text);
	}

	void addDropDown(const char* name, int ID) // could add multi-level dropdown but nah
	{
		HMENU newDropDown = CreateMenu();
		AppendMenu(menuBar, MF_POPUP, reinterpret_cast<uintptr_t>(newDropDown), name);
		dropdowns[ID] = newDropDown;
	}
};
